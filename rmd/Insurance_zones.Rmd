---
title: "Determination of insurance zones"
author: "Benson Kenduiywo"
date: "04/06/2020"
output:
  pdf_document: default
  html_document: default
editor_options:
  chunk_output_type: console
---

## Data preparation

Load packages (from the library)
 
```{r lib, message=FALSE}
library(reshape2)
library(dplyr)

#remotes::install_github("reagro/agro")
#remotes::install_github("reagro/agrodata")

library(agrodata)
#path <- "D:/UCDavis/QUIIC/github/IBLI/"
#source(paste0(path,"scripts/Functions.R"))
#source("../scripts/Functions.R")
```

Sublocation boundaries

```{r d12}
#subloc <- shapefile(paste0(path,"data/marsabit_subloc_ibli.shp"))
subloc <- agrodata::data_ibli("marsabit")
names(subloc)[6] <- "sublocation"
subloc
```

### NDVI and rainfall data.

```{r d1}
#library(agrins)
#library(agrodata)
n <- agrodata::data_ibli("marsabit_avhrr_ndvi") #NOAA
colnames(n)[1:5]
p <- agrodata::data_ibli("marsabit_chirps_precipitation")
colnames(p)[1:5]
```


Reshape the data from wide to long with date as a variable.

```{r d2}
p <- reshape2::melt(p, variable.name = "date", value.name = "rain",id.vars = "SUBLOCATION")
colnames(p) <- tolower(colnames(p))
p[1,]

# equivalent to
#p2 <- data.frame(p[,1,drop=FALSE], 
#                 date=rep(colnames(p)[-1], each=nrow(p)), 
#                 rain=as.vector(as.matrix(p[,2:ncol(p)])))
# and to
#cn <- colnames(p)[2:ncol(p)]
#p2 = reshape(p, direction="long", idvar="SUBLOCATION", timevar="date", varying=cn, times=cn, v.names="rainfall", new.row.names=1:(nrow(p)*(ncol(p)-1)))

n <- reshape2::melt(n, variable.name = "date", value.name = "ndvi", id.vars = "SUBLOCATION")
colnames(n) <- tolower(colnames(n))
n[1,]

```

Compute seasonal mean rainfall and NDVI for each year.

```{r d4}
season_mean <- function(d, v){
	d$month <- as.integer(substr(d$date, 6, 7))
	d$year <- as.integer(substr(d$date, 2, 5))
	d$season <- ifelse(d$month>2 & d$month<10, "LRLD", "SRSD")
	aggregate(d[,v,drop=FALSE], d[,c("sublocation", "year", "season")], mean, na.rm=TRUE)
}

p <- season_mean(p, "rain")
p <- p[p$year > 1981, ]

n <- season_mean(n, "ndvi")
n <- n[n$year > 1981, ]
```

Compute the zScored daily average rainfall per season per sublocation.

I do not uderstand a thing the below, but the results seem wrong 
```{r d4a}
zscore <- function(y){ (y - mean(y, na.rm=TRUE) ) / (sd(y, na.rm=TRUE))}
xrain <- dplyr::ungroup(dplyr::mutate(dplyr::group_by(p, sublocation), zrain=zscore(rain)))
xndvi <- dplyr::ungroup(dplyr::mutate(dplyr::group_by(n, sublocation), zndvi=zscore(ndvi)))
```

At least they are different from a conventional computation. 
Or perhaps your intent was different?

```{r d4b}
z_score <- function(d, v){
  a <- aggregate(d[,v], d[,c("sublocation", "season")], function(i) cbind(mean(i, na.rm=TRUE), sd(i, na.rm=TRUE)))
  a <- do.call(data.frame, a)
  colnames(a)[3:4] <- c("mean", "sd")
  d <- merge(d, a)
  d[, paste0("z", v)] <- (d[,v] - d$mean) / d$sd
  #d$mean <- NULL
  #d$sd <- NULL
  d[order(d$year, d$season, d$sublocation), ]
}

rain <- z_score(p, "rain")
ndvi <- z_score(n, "ndvi")

head(rain)
head(xrain)

```


### Livestock data

Mortality and causes of mortality data

```{r d13}
mort <- agrodata::data_ibli("marsabit_mortality.rds")
cause <- agrodata::data_ibli("marsabit_losses")[,c("hhid", "sublocation", "cause","month", "year")]
cause$season <- "SRSD"
cause$season[cause$month >=3 & cause$month <=9] <-"LRLD"
head(cause, n=2)
mort<- merge(mort, cause, by=c("hhid","sublocation", "season", "year"))
```

Compute mortality

```{r d5}
#Consider: Disease, Starvation, Rain, predation
mort <- mort[!(mort$cause %in% c("Just lost", "Old age","Premature birth")),]
mort <- mort[mort$type == "TLU", ]
amort <- aggregate(mort[,c("stock_beginning", "loss"), drop=FALSE], mort[, c("season","year","sublocation"), drop=FALSE], mean, na.rm=TRUE)

amort$mortality_rate <- amort$loss / amort$stock_beginning
```

### Merge mortality with NDVI and rainfall data.

```{r d6}
d <- merge(ndvi, amort, by=c("year", "season", "sublocation"))
d <- merge(rain, d, by=c("year", "season", "sublocation"))
d$mortality_rate <- d$mortality_rate * 100
```

## Spatial Variation of mortality

Display the spatial variation on mortality.

STOP! for the merge below to work you need terra >= 0.6-15

```{r sv1}
temp <- aggregate(amort[, "mortality_rate", drop=FALSE], amort[, c("season", "sublocation"), drop=FALSE],mean, na.rm=T)
#LRLD
lr <- terra::merge(subloc, temp[temp$season=="LRLD", c("sublocation", "mortality_rate")], by= "sublocation")
#SRSD
sr <- terra::merge(subloc, temp[temp$season=="SRSD", c("sublocation", "mortality_rate")], by= "sublocation")

cols <- heat.colors(length(lr$sublocation), rev=T)
#Rainfal spatial variation
#x11()
par(mfrow=c(1, 2), mar=c(1, 1, 2, 2)) #c(bottom, left, top, right)
raster::spplot(lr, "mortality_rate", col.regions=cols, main="LRLD mean mortality")
raster::spplot(sr, "mortality_rate", col.regions=cols, main="SRSD mean mortality")
```


## Clustering zones

Use kmeans to cluster zones based on NDVI and rainfall per season per year

```{r z1}
#Convert long to Wide
n_w <- reshape2::dcast(ndvi, sublocation ~ year+season, value.var="ndvi")
r_w <- reshape2::dcast(rain, sublocation ~ year+season, value.var="rain")
df <- merge(n_w, r_w, by=c("sublocation"))
#subs <- sort(unique(rain$sublocation))
#aoi <- subloc[subloc$sublocation %in% subs,]
#df1 <- df[df$sublocation %in% subs,]
set.seed(99)
#rf <-  randomForest(df[,-1],ntree=200,importance = TRUE)
#Create 10 clusters using 500 iterations using 5 random sets from "Lloyd" method 
r_kmn <- kmeans(df[,-1], centers = 10, iter.max = 500, nstart = 5, algorithm="Lloyd")
# kmeans returns an object of class "kmeans"
subloc$zone <- r_kmn$cluster
```

Display the old and new zones

```{r z2, message=FALSE}
#x11()
terra::plot(subloc, "zone")
#text(subloc, subloc$zone, cex=.8)
#Merge to current boundaries
z_10 <- aggregate(subloc, by="zone")
terra::lines(z_10, col="red", lwd = 2)
plot(z_10)
```

## Effect of zones on mortality predictions

We will determine zones between 4--10 and evaluate the effect of the zones on mortality predictions based on R$^2$, Mean Absolute Prediction Error (MAPE) and RMSE. For instance, a MAPE of (1) < 10 indicates highly accurate prediction, while (2) 10--0 good prediction, 3) 20 -- reasonable prediction, and (4) > 50 inaccurate.

```{r e1}
rmse <- function(error){ return(sqrt(mean(error^2)))}
MAPE <- function (y_pred, y_true){ mean(abs((y_true - y_pred)/y_true)) * 100 }
R_square <- function(actual, predicted) { 1 - (sum((actual-predicted)^2)/sum((actual-mean(actual))^2))} 

d <- d[!is.na(d$mortality_rate), ]
zones <- 2:15 #c(4:10)
r_n <- e_n <- r_r <- e_r <- mape_n <- mape_r <- NULL
#Construct a Global mortality model based on NDVI & rainfall
m_r <- loess(mortality_rate ~ zrain , data=d, control=loess.control(surface="direct"))
m_n <- loess(mortality_rate ~ zndvi, data=d, control=loess.control(surface="direct"))

df1 <- df

for(z in 1:length(zones)){
  set.seed(99)
  r_kmn <- kmeans(df1[,-1], centers = zones[z], iter.max = 500, nstart = 2, algorithm="Lloyd")
  subloc$zone <- r_kmn$cluster
  #df2 <- 0
  df2 <- merge(d, as.data.frame(subloc[,c("sublocation", "zone")]), by="sublocation")
  df2 <- ungroup(mutate(group_by(df2, season, year, zone), 
                       zrain=mean(zrain), zndvi=mean(zndvi)))
  #Rainfall
  p <- predict(m_r, df2)
  r_r[z] <- R_square(df2$mortality_rate, p)
  e_r[z] <- rmse(df2$mortality_rate - p)
  mape_r[z] <- MAPE(df2$mortality_rate, p)
  #NDVI
  p <- predict(m_n, df2)
  r_n[z] <- R_square(df2$mortality_rate, p)
  e_n[z] <- rmse(df2$mortality_rate - p)
  mape_n[z] <- MAPE(df2$mortality_rate, p)
}

quality <- data.frame(No_Zone=zones, ndvi_R2=r_n, rain_R2=r_r, ndvi_RMSE=e_n,rain_RMSE=e_r,ndvi_mape=mape_n,rain_mape=mape_r)
quality

```

Plot the influence of zone size on R$^2$ and RMSE of the mortality model.

```{r e2}
#windows()
#par(mfrow=c(1,2),mar=c(15,4.5,1,1))
par(mfrow=c(1, 2), mar=c(15, 4.5, 2, 0.5)) #c(bottom, left, top, right)
plot(zones, r_n, type="l", ylim= c(0,1), col="green", ylab=expression(R^2), xlab= "Sub-location clusters", cex.axis =1.2, cex.lab = 1.2, lwd=2)
lines(zones, r_r, col="blue", lwd=2)
legend("topright", c("NDVI", "Rainfall"), col=c("green","blue"), lty = 1, lwd=2)

plot(zones, mape_n, type="l", ylim= c(0,100), col="green", ylab="MAPE (%)", xlab= "Sub-location clusters", cex.axis =1.2, cex.lab = 1.2,lwd=2)
lines(zones, mape_r, col="blue",lwd=2)
legend("topright", c("NDVI", "Rainfall"), col=c("green","blue"), lty = 1, lwd=2)

```

## Influence of number zones on MQS

We evaluate the influence of zone clusters on insurance welfare using MQS based on a risk aversion coefficient $\rho=1.5$ -- which falls within the common range for risk-averse farming communities.

```{r mqs1}
library(agro)
test <- function(rhos, df1){
  ce_base <- ce_ins <- ce_ins_nomarkup<- mqs <- mqs_no <- rep(NA, length(rhos))
  for(i in 1:length(rhos)){
    ce_base[i] <- ce_income(df1$y_noins, rhos[i])
    ce_ins[i]  <- ce_income(df1$y_25markup, rhos[i])
    ce_ins_nomarkup[i] <- ce_income(df1$y_nomarkup, rhos[i])
    mqs[i]    <- ce_ins[i] - ce_base[i]
    mqs_no[i] <- ce_ins_nomarkup[i] - ce_base[i]
  }
  return(list(mqs=mqs,mqs_no=mqs_no))
}



markup <- 0.25
rhos <- 1.5 #seq(0, 5, .1)
mqs_n <- mqs_r <- vector("list", length(rhos))
for(z in 1:length(zones)){
  set.seed(99)
  r_kmn <- kmeans(df1[,-1], centers = zones[z], iter.max = 500, nstart = 2, algorithm="Lloyd")
  subloc$zone <- r_kmn$cluster
  df2 <- 0
  df2 <- merge(d, as.data.frame(subloc[,c("sublocation", "zone")]), by="sublocation")
  df2 <- ungroup(mutate(group_by(df2, season, year, zone), 
                       zrain=mean(zrain), zndvi=mean(zndvi)))
  #1.0 Mortality model
  #Rainfall
  df2$rain_mortality <- predict(m_r, df2)
  #NDVI
  df2$ndvi_mortality <- predict(m_n, df2)
  #2.0 Contract design
  r_trig <- quantile(df2$rain_mortality, 0.80, na.rm=T)
  n_trig <- quantile(df2$ndvi_mortality, 0.80, na.rm=T)
  #make payouts; 1 TLU=100$
  df2$r_pay <- pmax(0, df2$rain_mortality - r_trig)/100 * 1000
  df2$n_pay <- pmax(0, df2$ndvi_mortality - n_trig)/100 * 1000
  #3.0 Evaluation
  #NDVI
  df2$capital <- (100 - df2$mortality_rate) * 1000
  n_premium <- mean(df2$n_pay) * (1 + markup)
  df_n <- data.frame(y_noins = df2$capital) # no insurance
  df_n$y_nomarkup <- (df2$capital + df2$n_pay) - mean(df2$n_pay) #no markup
  df_n$y_25markup <- (df2$capital + df2$n_pay) - n_premium #marked up
  #Rainfall model premiums
  r_premium <- mean(df2$r_pay) * (1 + markup)
  df_r <- data.frame(y_noins = df2$capital)
  df_r$y_nomarkup <- (df2$capital + df2$r_pay) - mean(df2$r_pay)
  df_r$y_25markup <- (df2$capital + df2$r_pay) - r_premium
  #4.0 MQS test
  mqs_n[[z]] <- test(rhos, df_n)
  mqs_r[[z]] <- test(rhos, df_r)

}

```

We have made a welfare test on the various zones we have created. Let us now make a plot to evaluate if the size of the zone clusters influence insurance welfare in any way.

```{r mqs2}
a <-  matrix(unlist(mqs_n),ncol=2,byrow=TRUE)
b <-  matrix(unlist(mqs_r),ncol=2,byrow=TRUE)
#x11()
plot(zones, a[,1], type="l", col="red", ylab= "MQS (insurance benefit per TLU in $)", xlab="Sub-location clusters", cex=2, ylim=c(0, 30), main=expression(paste(rho," = 1.5")))
lines(zones, a[,2], col="green")
lines(zones, b[,2], col="magenta")
lines(zones, b[,1], col="blue")
legend("topright", c("NDVI 25% Marked-up", "NDVI No mark up", "Rainfall No mark up", "Rainfall 25% Marked-up"), lty=1, col=c("red", "green", "magenta", "blue"), title = "Insurance type", bty = "n")

```

Consider a highly risk averse farmer $\rho=5$

```{r mqs3}
markup <- 0.25
rhos <- 5 #seq(0, 5, .1)
mqs_n <- mqs_r <- vector("list", length(rhos))
for(z in 1:length(zones)){
  set.seed(99)
  r_kmn <- kmeans(df1[,-1], centers = zones[z], iter.max = 500, nstart = 2, algorithm="Lloyd")
  subloc$zone <- r_kmn$cluster
  df2 <- merge(d, as.data.frame(subloc[,c("sublocation", "zone")]), by="sublocation")
  
  df2 <- ungroup(mutate(group_by(df2, season, year, zone), 
                       zrain=mean(zrain), zndvi=mean(zndvi)))
  #1.0 Mortality model
  #Rainfall
  df2$rain_mortality <- predict(m_r, df2)
  #NDVI
  df2$ndvi_mortality <- predict(m_n, df2)
  #2.0 Contract design
  r_trig <- quantile(df2$rain_mortality, 0.80, na.rm=T)
  n_trig <- quantile(df2$ndvi_mortality, 0.80, na.rm=T)
  #make payouts; 1 TLU=100$
  df2$r_pay <- pmax(0, df2$rain_mortality - r_trig)/100 * 1000
  df2$n_pay <- pmax(0, df2$ndvi_mortality - n_trig)/100 * 1000
  #3.0 Evaluation
  #NDVI
  df2$capital <- (100 - df2$mortality_rate) * 1000
  n_premium <- mean(df2$n_pay) * (1 + markup)
  df_n <- data.frame(y_noins = df2$capital) # no insurance
  df_n$y_nomarkup <- (df2$capital + df2$n_pay) - mean(df2$n_pay) #no markup
  df_n$y_25markup <- (df2$capital + df2$n_pay) - n_premium #marked up
  #Rainfall model premiums
  r_premium <- mean(df2$r_pay) * (1 + markup)
  df_r <- data.frame(y_noins = df2$capital)
  df_r$y_nomarkup <- (df2$capital + df2$r_pay) - mean(df2$r_pay)
  df_r$y_25markup <- (df2$capital + df2$r_pay) - r_premium
  #4.0 MQS test
  mqs_n[[z]] <- test(rhos, df_n)
  mqs_r[[z]] <- test(rhos, df_r)

}

```

Make a plot to evaluate if the size of the zone clusters influence insurance welfare in any way.

```{r mqs4}
a <-  matrix(unlist(mqs_n),ncol=2,byrow=TRUE)
b <-  matrix(unlist(mqs_r),ncol=2,byrow=TRUE)
plot(zones, a[,1], type="l", col="red", ylab= "MQS (insurance benefit per TLU in $)", xlab="Sub-location clusters", cex=2, ylim=c(0, 300), main=expression(paste(rho," = 5")))
lines(zones, a[,2], col="green")
lines(zones, b[,2], col="magenta")
lines(zones, b[,1], col="blue")
legend("topright", c("NDVI 25% Marked-up", "NDVI No mark up", "Rainfall No mark up", "Rainfall 25% Marked-up"), lty=1, col=c("red", "green", "magenta", "blue"), title = "Insurance type", bty = "n")

```


## References

Lewis, C. D., 1982. *Industrial and business forecasting methods: a practical guide to exponential smoothing and curve fitting*. Butterworth Scientific, London Boston.
