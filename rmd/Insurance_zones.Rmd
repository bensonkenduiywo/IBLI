---
title: "Determination of insurance zones"
author: "Benson Kenduiywo"
date: "04/06/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data preparation

Load libraries
 
```{r lib}
rm(list = ls(all=TRUE))
library(agrins)
library(reshape2)
library(dplyr)
path <- "D:/UCDavis/QUIIC/github/IBLI/"
source(paste0(path,"scripts/Functions.R"))
```
Load data.

```{r d1}
#NDVI
n <- data_ibli("marsabit_avhrr_ndvi") #NOAA
#Precipitation
p <- data_ibli("marsabit_chirps_precipitation")
names(p)[1:10]
#Adim boundary
subloc <- shapefile(paste0(path,"data/marsabit_subloc_ibli.shp"))
names(subloc)[6] <- "sublocation"
#Mortality
mort <- data_ibli("marsabit_mortality.rds")
#Causes of mortality data
cause <- data_ibli("marsabit_losses")[,c("hhid", "sublocation", "cause","month", "year")]
colnames(cause)[4] <- "season"
s <- cause$season
cause$season <- "SRSD"
cause$season[s >=3 & s <=9] <-"LRLD"
cause <- na.omit(cause)
head(cause, n=2)
```

Reshape the data from wide table to long with year as variable.

```{r d2}
#http://www.cookbook-r.com/Manipulating_data/Converting_data_between_wide_and_long_format/
p2 <- melt(p, variable.name = "date", value.name = "rainfall",id.vars = "SUBLOCATION")
p2[1,]
n2 <- melt(n, variable.name = "date", value.name = "ndvi", id.vars = "SUBLOCATION")
n2[1,]

```

Format the date variable by removing unnecessary variables.

```{r d3}
#Chirps
date <- gsub("X", "", p2$date)
p2$date <- as.Date(as.character(date), format = "%Y%m%d")
p2[1,]
#NOAA
date <- gsub("X", "", n2$date)
n2$date <- as.Date(as.character(date), format = "%Y%m%d")
n2[1,]

```
Merge causes table with mortality data.

```{r d3a}
mort2  <- merge(mort, cause, by=c("hhid","sublocation", "season", "year"))

```
Compute daily average rainfall and NDVI per season in each year.

```{r d4}
years <- seq(1982, 2019, 1)
LR_rain <- lapply(years, seasonMean, p2, "long")
LR_rain <- do.call(rbind, LR_rain)
names(LR_rain)[2] <- "rainfall"
SR_rain <- lapply(years, seasonMean, p2, "short")
SR_rain <- do.call(rbind, SR_rain)
names(SR_rain)[2] <- "rainfall"
rain <- rbind(LR_rain, SR_rain)
#NDVI
LR_ndvi <- lapply(years, seasonMean, n2, "long")
LR_ndvi <- do.call(rbind, LR_ndvi)
names(LR_ndvi)[2] <- "ndvi"
SR_ndvi <- lapply(years, seasonMean, n2, "short")
SR_ndvi <- do.call(rbind, SR_ndvi)
names(SR_ndvi)[2] <- "ndvi"
ndvi <- rbind(LR_ndvi, SR_ndvi)

```

Compute the zScored daily average rainfall per season per sublocation.

```{r d4a}
rain <- ungroup(mutate(group_by(rain,SUBLOCATION), 
                       zrain=zscore(rainfall)))

ndvi <- ungroup(mutate(group_by(ndvi,SUBLOCATION), 
                       zndvi=zscore(ndvi)))
```

Compute mortality.

```{r d5}
#Consider: Disease, Starvation, Rain, predation
mort2 <- mort2[!(mort2$cause %in% c("Just lost", "Old age","Premature birth")),]
mort2 <- mort2[mort2$type == "TLU", ]
mort2 <- na.omit(mort2)
amort <- aggregate(mort2[,c("stock_beginning", "loss"), drop=FALSE], mort2[, c("season","year","sublocation"), drop=FALSE], mean, na.rm=TRUE)
amort$mortality_rate <- amort$loss/amort$stock_beginning

```

Merge mortality with NDVI and rainfall data.

```{r d6}
colnames(ndvi)[1] <- "sublocation"
d <- merge(ndvi, amort, by=c("year", "season", "sublocation"))
colnames(rain)[1] <- "sublocation"
d <- merge(rain, d, by=c("year", "season", "sublocation"))
d$mortality_rate <- d$mortality_rate * 100
```

## Clustering zones

Use kmeans to cluster zones based on NDVI and rainfall per season per year

```{r z1, echo=FALSE}

#Convert long to Wide
#==================================
n_w <- dcast(ndvi, sublocation ~ year+season, value.var="ndvi")
r_w <- dcast(rain, sublocation ~ year+season, value.var="rainfall")
df <- merge(n_w,r_w, by=c("sublocation"))

set.seed(99)
#Create 10 clusters using 500 iterations using 5 random sets from "Lloyd" method
r_kmn <- kmeans(df[,-1], centers = 10, iter.max = 500, nstart = 5, algorithm="Lloyd")
# kmeans returns an object of class "kmeans"
subloc$Zones <- r_kmn$cluster

```
Display the old and new zones

```{r z2}
x11()
plot(subloc, main= "NDVI+Rain")
text(subloc, subloc$Zones)
#Merge to current boundaries
z_10 <- aggregate(subloc, by="Zones")
plot(z_10, add = TRUE, border = "red", lwd = 2)

```

## Effect of zones on mortality predictions

We will determine zones between 4--10 and evaluate the effect of the zones on mortality predictions based on R$^2$, Mean Absolute Prediction Error (MAPE) and RMSE

```{r e1}
zones <- c(4:10)
#par(mfrow=c(4, 2), mar=c(.1, .1, .1, .1)) #c(bottom, left, top, right)
r_n <- c()
e_n <- c()
r_r <- c()
e_r <- c()
for(z in 1:length(zones)){
  set.seed(99)
  r_kmn <- kmeans(df[,-1], centers = zones[z], iter.max = 500, nstart = 4, algorithm="Lloyd")
  # kmeans returns an object of class "kmeans"
  subloc$Zones <- r_kmn$cluster
  df2 <- 0
  df2 <- merge(d,subloc[,-c(1:5,7:12)], by="sublocation")
  df2 <- aggregate(df2[,c("mortality_rate", "zndvi","zrain"), drop=FALSE], df2[, c("season","year","Zones"), drop=FALSE], mean, na.rm=TRUE)
 
  #Rainfall
  m_r <- loess(mortality_rate ~ zrain , data=df2, control=loess.control(surface="direct"))
  p <- predict(m_r, df2)
  cat(zones[z], " zones: Rain model R2: ", R_square(df2$mortality_rate, p), "\n")
  r_r[z] <- R_square(df2$mortality_rate, p)
  e_r[z] <- rmse(df2$mortality_rate - p)
  #NDVI
  m_n <- loess(mortality_rate ~ zndvi, data=df2, control=loess.control(surface="direct"))
  p <- predict(m_n, df2)
  cat(zones[z], " zones: NDVI model R2: ", R_square(df2$mortality_rate, p), "\n")
  r_n[z] <- R_square(df2$mortality_rate, p)
  e_n[z] <- rmse(df2$mortality_rate - p)
}


```

Plot the influence of zone size on R$^2$ and RMSE of the mortality model.

```{r e2}
windows()
par(mfrow=c(1,2),mar=c(13,4.5,1,1))
plot(zones, r_n, type="l", ylim= c(0,1), col="red", ylab="RMSE (tons/ha)", xlab= "n-fold", cex.axis =1.2, cex.lab = 1.2)
lines(iterations, rf_a, col="blue")
legend("topright", c("SVM", "RF"), col=c("red","blue"), lty = 1)

plot(iterations, svm_b, type="l", ylim= c(0,100), col="red", ylab="MAPE (%)", xlab= "n-fold", cex.axis =1.2, cex.lab = 1.2)
lines(iterations, rf_b, col="blue")
legend("topright", c("SVM", "RF"), col=c("red","blue"), lty = 1)

windows()
par(mar=c(4.5,4.5,1,1))
plot(iterations, r_svm, type="l", ylim= c(0,1), col="red", ylab=expression(R^2), xlab= "n-fold", cex.axis =1.2, cex.lab = 1.2)
lines(iterations, r_rf, col="blue")
legend("topright", c("SVM", "RF"), col=c("red","blue"), lty = 1)

```

