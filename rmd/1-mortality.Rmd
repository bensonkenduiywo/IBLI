---
title: "Experiments for ideas of 25 June 2020"
author: "Benson Kenduiywo"
date: "26/06/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

## Packages

install the latest versions of raster, terra and agrodata (`remotes::install_github("reagro/agrodata")`) in that order. 

```{r lib, message=FALSE}
library(agrodata)
library(dplyr)
```

## Data preparation

### Administrative data

Load sub-location boundaries

```{r d12}
subloc <- agrodata::data_ibli("marsabit")
names(subloc)[6] <- "sublocation"
subloc
```

### NDVI and rainfall data.

Get Normalized Difference Vegetative Index (NDVI) data from NOAA-AVHRR, MODIS and rainfall from CHIRPS. The datasets are already spatially aggregated (mean) with respect to sublocation boundaries.

```{r d1}
n <- agrodata::data_ibli("marsabit_avhrr_ndvi") #NOAA
colnames(n)[1:5]
m <- agrodata::data_ibli("marsabit_modis_ndvi_agg") #MODIS
colnames(m)[1] <- toupper(colnames(m)[1])
colnames(m)[1:5]
p <- agrodata::data_ibli("marsabit_chirps_precipitation") #rainfall
colnames(p)[1:5]
```


Reshape the data from wide to long with date as a variable. 

```{r d2}
p <- reshape2::melt(p, variable.name = "date", value.name = "rainfall",id.vars = "SUBLOCATION")
p[1,]
n <- reshape2::melt(n, variable.name = "date", value.name = "noaa", id.vars = "SUBLOCATION")
n[1,]
m <- reshape2::melt(m, variable.name = "date", value.name = "modis", id.vars = "SUBLOCATION")
m[1,]

```

Format the date variable by removing unnecessary variables.

```{r d3}
#Chirps
p$date <- as.Date(p$date, format = "X%Y%m%d")
p[1,]
#NOAA
n$date <- as.Date(n$date, format = "X%Y%m%d")
n[1,]
#MODIS
m$date <- as.Date(m$date, format = "X%Y_%m_%d")
m[1,]

```
Compute daily average rainfall and NDVI per season in each year. First Create a function to compute means for Long Rain Long Dry (March -- September) and Short Rain Short Dry (October -- February) seasons.

```{r fxn1}
seasonMean <- function(year, df, seasons=1:2) {
	#df$date <- as.Date(df$date, format = "X%Y%m%d")
  res <- list()
  for (i in seasons) {
    season <- ifelse(i==1, "long", "short")
    if (season =="long") {
      sdate <- paste0(year, "-03-01")
      edate <- paste0(year, "-09-30")
      season <- "LRLD"
    } else if (season =="short") {
      sdate <- paste0(year-1, "-10-01")
      edate <- paste0(year, "-02-28")
      season <- "SRSD"
    } else {
      stop("Define season")
    }
    ydf <- df[df$date >= sdate & df$date <= edate, ]
    ym <- aggregate(ydf[,3], ydf[,1, drop=FALSE], mean, na.rm=T)
    ym$year <- year
    ym$season <- season
    res[[i]] <- ym    
  }  
  do.call(rbind, res)  
}

```

Now compute the averages using the function.

```{r d4}
years <- 1982:2019
#CHIRPS
temp <- lapply(years, seasonMean, p)
p <- do.call(rbind, temp)
names(p)[2] <- "rainfall"

#NOAA NDVI
temp <- lapply(years, seasonMean, n)
n <- do.call(rbind, temp)
names(n)[2] <- "noaa"

#MODIS NDVI
years <- 2001:2019
temp <- lapply(years, seasonMean, m)
m <- do.call(rbind, temp)
names(m)[2] <- "modis"
```


### Livestock data

Mortality and causes of mortality data

```{r d13}
mort <- agrodata::data_ibli("marsabit_mortality.rds")
colnames(mort)[colnames(mort)=="type"] <- "animal"
mort <- mort[mort$animal %in% c("Camel", "Cattle", "Shoat"), ]  # remote TLU for merging
mort <- mort[!is.na(mort$mortality_rate), ]                     # remove zero stock

cause <- agrodata::data_ibli("marsabit_losses")[,c("hhid", "sublocation", "animal", "cause","month", "year")]
cause$animal[cause$animal == "Goat/Sheep"] <- "Shoat"
cause$season <- "SRSD"
cause$season[cause$month >=3 & cause$month <=9] <-"LRLD"
head(cause, n=2)
cause <- na.omit(unique(cause))
table(cause$cause)
```

Merge causes table with mortality data.

We cannot really merge these. For now, to make progress, let's just drop that
```{r d3a}
nrow(mort)
nrow(cause)
mortx  <- merge(mort, cause, by=c("hhid","sublocation", "animal", "season", "year"), all.x=TRUE)
nrow(mortx)
```

Compute mortality

It might be of interest to do a seperatre model for Starvation/Drought


```{r d5}
#Consider: Disease, Starvation, Rain, predation
#  can also be stress induced
#mort2 <- mort2[!(mort2$cause %in% c("Just lost", "Old age", "Premature birth")),]
#mort2 <- mort2[mort2$type == "TLU", ]
#mort2 <- na.omit(mort2)

mort <- agrodata::data_ibli("marsabit_mortality.rds")
mort2 <- mort[mort$type == "TLU", ]  # remote TLU for merging

amort <- aggregate(mort2[,c("stock_beginning", "loss"), drop=FALSE], mort2[, c("season","year","sublocation"), drop=FALSE], mean, na.rm=TRUE)
amort$mortality_rate <- (amort$loss / amort$stock_beginning) * 100
```

## Normal vs lognormal data treament 

compute z-Score based data time series lengths. Z-score function.

```{r zscore}
zscore <- function(y){ 
  (y - mean(y, na.rm=TRUE) ) / (sd(y, na.rm=TRUE))
}
```

Compute Z-scores.

```{r n2}
df1 <- merge(p, n, by = c("SUBLOCATION","year", "season")) #NOAA and CHIRPSs
df1 <- merge(df1, m, by = c("SUBLOCATION","year", "season"), all.x=TRUE)

dff <- ungroup(mutate(group_by(df1, SUBLOCATION, season), znoaa=zscore(noaa), zrain=zscore(rainfall), zmodis=zscore(modis),  zlnoaa=zscore(log(noaa)), zlrain=zscore(log(rainfall)), zlmodis=zscore(log(modis))))

```

Check predictors distributions.

```{r nn1, message=FALSE}
library(MASS)
distfun <- function(x, main="") {
   x <- na.omit(x)
   par(mfrow=c(1,2))
   for (i in 1:2) {
     if(i==2) x <- na.omit(log(x))
     hist(x, breaks=30, prob=TRUE, xlab="index", main = ifelse(i==1, main, "log"))
     fit <- fitdistr(x, "normal")
     curve(dnorm(x, fit$estimate[1], fit$estimate[2]), col = "red", lwd=2, add = TRUE)
   }
}
```

NOAA

```{r nn11, message=FALSE}
distfun(na.omit(dff$noaa), main="NOAA")
```


MODIS NDVI
```{r nn2}
distfun(dff$modis, main="MODIS")
```

CHIPRS
```{r nn3}
distfun(dff$rainfall)
```


It seems the *log* transforms the rainfall data to a distribution close to normal. We will thus compute zScored log of transformed daily average rainfall and NDVI per season per sub-location.

--- RH: This is especially true for rainfall, but I think that all three should be transformed ---- 

Merge mortality with NDVI and rainfall data.

```{r d6}
colnames(amort)[3] <- "SUBLOCATION"
dff <- merge(dff, amort, by=c("year", "season", "SUBLOCATION"))
```


## Mortality modelling and prediction

We will determine the effect rainfall data transformation on mortality predictions based on R$^2$, Mean Absolute Prediction Error (MAPE) and RMSE. For instance, a MAPE of (1) < 10 indicates highly accurate prediction, while (2) 10--0 good prediction, 3) 20 -- reasonable prediction, and (4) > 50 inaccurate.

MAPE, RMSE and R$^2$ functions are given as:

```{r fxn2}
rmse <- function(error){ return(sqrt(mean(error^2, na.rm=TRUE)))}
MAPE <- function (y_pred, y_true){ mean(abs((y_true - y_pred)/y_true), na.rm=TRUE) * 100 }
Rsq <- function(actual, predicted) { 
  d <- na.omit(data.frame(actual, predicted))
  1 - (sum((d$actual-d$predicted)^2)/ sum((d$actual - mean(d$actual))^2)) 
} 
```


## Regime switching linear regression vs lowess

Here we test a piecewise linear regression model against the lowess model. Piecewise will consider two  regimes; those when conditions are below zero and above it.

```{r p1}
library(segmented)

regfun <- function(x, y, main="") {
  df <- na.omit(data.frame(x=x, y=y))
  df0 <- df[df$x<0,]
  df5 <- df[df$x < -0.5,]
  test <- matrix(nrow=5,ncol=2)
  colnames(test) <- c("r2", "RMSE")
  rownames(test) <- c("lm", "lm0", "lm5", "seg", "loess")
  plot(y~x, pch=16, main=main)

  ml <- lm(y~x, data=df)
  abline(ml, col="light blue", lwd=3, lty=2)  
  ml2 <- lm(y~x, data=df0)
  abline(ml2, col="blue", lwd=3, lty=3)  
  ml5 <- lm(y~x, data=df5)
  abline(ml5, col="dark blue", lwd=3, lty=4)  

  sm <- segmented(ml, seg.Z = ~x, psi=0)
  plot.segmented(sm, add=T, lwd=2, col="red") 
  mz <- loess(y~x, df, control=loess.control(surface="direct"))
  px=seq(-3, 3, .01)
  lines(px, predict(mz, data.frame(x=px)), lwd=2, col="dark green")
  #legend

  e <- predict(ml)
  test[1,] <- c(Rsq(df$y, e), rmse(df$y - e))
  e <- predict(ml2)
  test[2,] <- c(Rsq(df0$y, e), rmse(df0$y - e))
  e <- predict(ml5)
  test[3,] <- c(Rsq(df5$y, e), rmse(df5$y - e))
  e <- predict(sm)
  test[4,] <- c(Rsq(df$y, e), rmse(df$y - e))
  e <- predict(mz)
  test[5,] <- c(Rsq(df$y, e), rmse(df$y - e))
  test
}

```


```{r}
regfun(dff$znoaa, dff$mortality_rate, "NOAA")
```

```{r}
regfun(dff$zlnoaa, dff$mortality_rate, "log NOAA")
```

```{r}
regfun(dff$zrain, dff$mortality_rate, "rain")
```

```{r}
regfun(dff$zlrain, dff$mortality_rate, "log rain")
```


```{r}
regfun(dff$zmodis, dff$mortality_rate, "modis")
```

```{r}
regfun(dff$zlmodis, dff$mortality_rate, "log modis")
```


```{r}
x=dff$znoaa
y=dff$mortality_rate
pcs1 <- lm(y ~ x*(x <= -1) + x*(x >= -1))
#summary(pcs1)
coef <- summary(pcs1)$coefficients
intercept_a <- coef[1,1] + coef[2,1]
slope_a <- (coef[2,1] + coef[3,1]) 
plot(y~x)
curve(slope_a*x + intercept_a, add=T, from=-3, to=2, col="red")
###2 not defined because of singularities CHALLANGEE
```

