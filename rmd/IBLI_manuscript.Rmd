---
title: "IBLI contract design and evaluation based on chirps and NDVI"
author: "Benson Kenduiywo"
date: "22/11/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## IBLI Programme Design and Evaluation using CHIRPS rainfall data

Load libraries
 
```{r lib}
rm(list = ls(all=TRUE))
library(agrins)
library(reshape2)
library(dplyr)

```

Load precipitation and NDVI data.

```{r d1}
n <- data_ibli("marsabit_avhrr_ndvi") #NOAA
p <- data_ibli("marsabit_chirps_precipitation")
names(p)[1:10]

```

Reshape the data from wide table to long with year as variable.

```{r d2}
p2 <- melt(p, variable.name = "date", value.name = "rainfall", id.vars = "SUBLOCATION")
p2[1,]

n2 <- melt(n, variable.name = "date", value.name = "ndvi", id.vars = "SUBLOCATION")
n2[1,]
```

Format the date variable by removing unnecessary variables.

```{r d3}
#Chirps
date <- gsub("X", "", p2$date)
p2$date <- as.Date(as.character(date), format = "%Y%m%d")
p2[1,]
#NOAA
date <- gsub("X", "", n2$date)
n2$date <- as.Date(as.character(date), format = "%Y%m%d")
n2[1,]

```

Let us make some plots.

```{r plots}
plot(rainfall~date, data=p2, type="l", ylab="rainfall (mm)")
m <- months(p2$date)
i <- m == "September"
lines(p2$date[i], p2$rainfall[i], col="red", cex=1.2)
j <- m == "October"
lines(p2$date[j], p2$rainfall[j], col="blue", cex=1.2)
legend("topleft", lty = 1, col = c("red", "blue"), legend=c('September','October'), title="Month")


#1982-2019 average annual rainfall
p2$year <- as.numeric(format(p2$date,'%Y')) 
y <- aggregate(rainfall~year, p2, mean, na.rm=T)
x11()
plot(rainfall~year, data=y[-1,], type="l", ylab="rainfall (mm)", main="1982-2019 average annual rainfall", axes=F, cex.lab=1.2)
axis(side=1, at=seq(1982,2019, 2), cex.axis=1.1)
axis(side=2, at=seq(0, 5, by=1), cex.axis=1.1)
box()

#1982-2019 average annual NDVI
n2$year <- as.numeric(format(n2$date,'%Y')) 
y <- aggregate(ndvi~year, n2, mean, na.rm=T)
x11()
plot(ndvi~year, data=y[-1,], type="l", ylab="NDVI", main="1982-2019 average annual NDVI", axes=F, cex.lab=1.2)
axis(side=1, at=seq(1982,2019, 2), cex.axis=1.1)
axis(side=2, at=seq(0, 0.5, by=0.1), cex.axis=1.1)
box()

```

Create a function to compute means for Long Rain Long Dry (March -- September) and Short Rain Short Dry (October -- February) seasons.

```{r d4}
seasonMean <- function(year, df, season){
  if(season =="long"){
    sdate <- paste0(year, "-03-01")
    edate <- paste0(year, "-09-30")
    season <- "LRLD"
  }else if (season =="short"){
    sdate <- paste0(year-1, "-10-01")
    edate <- paste0(year, "-02-28")
    season <- "SRSD"
  }else{
    print("Define season")
  }
  ydf <- df[df$date >= sdate & df$date <= edate, ]
  ym <- aggregate(ydf[,3], ydf[,1, drop=FALSE], mean, na.rm=T)
  ym$year <- year
  ym$season <- season
  return(ym)
}

```

Compute daily average rainfall per season in each year.

```{r d5}
years <- seq(1982, 2019, 1)
LR_rain <- lapply(years, seasonMean, p2, "long")
LR_rain <- do.call(rbind, LR_rain)
names(LR_rain)[2] <- "rainfall"
SR_rain <- lapply(years, seasonMean, p2, "short")
SR_rain <- do.call(rbind, SR_rain)
names(SR_rain)[2] <- "rainfall"
rain <- rbind(LR_rain, SR_rain)

#1982-2019 average annual rainfall per season
y <- aggregate(rainfall~year+season, rain, mean, na.rm=T)
x11()
plot(rainfall~year, data=y, type="n", ylab="rainfall (mm)", main="1982-2019 average annual rainfall per season",  axes=FALSE, cex.lab=1.2)
axis(side=1, at=seq(1982,2019, 2), cex.axis=1.1)
axis(side=2, at=seq(0, 5, by=1), cex.axis=1.1)
box()
i <- y[y$season=="LRLD", ]
lines(rainfall~year, i, col="red", cex=1.2)
i <- y[y$season=="SRSD", ]
lines(rainfall~year, i, col="blue", cex=1.2)
legend("topleft", lty = 1, col = c("red", "blue"), legend=c('LRLD','SRSD'), title="Season")

#1982-2019 average annual NDVI per season
LR_ndvi <- lapply(years, seasonMean, n2, "long")
LR_ndvi <- do.call(rbind, LR_ndvi)
names(LR_ndvi)[2] <- "ndvi"
SR_ndvi <- lapply(years, seasonMean, n2, "short")
SR_ndvi <- do.call(rbind, SR_ndvi)
names(SR_ndvi)[2] <- "ndvi"
ndvi <- rbind(LR_ndvi, SR_ndvi)
y <- aggregate(ndvi~year+season, ndvi, mean, na.rm=T)
x11()
plot(ndvi~year, data=y, type="n", ylab="NDVI", main="1982-2019 average annual NDVI per season",  axes=FALSE, cex.lab=1.2)
axis(side=1, at=seq(1982,2019, 2), cex.axis=1.1)
axis(side=2, at=seq(0, 1, by=0.1), cex.axis=1.1)
box()
i <- y[y$season=="LRLD", ]
lines(ndvi~year, i, col="red", cex=1.2)
i <- y[y$season=="SRSD", ]
lines(ndvi~year, i, col="blue", cex=1.2)
legend("topleft", lty = 1, col = c("red", "blue"), legend=c('LRLD','SRSD'), title="Season")

```

Compute zScored average daily rainfall per season per Sub-location. First get the zScore function.

```{r d6}
zscore <- function(y){
  (y - mean(y, na.rm=TRUE) ) / (sd(y, na.rm=TRUE))
}

```

The compute the zScored daily average rainfall per season per sublocation.

```{r d7}
rain <- ungroup(mutate(group_by(rain,SUBLOCATION), 
                       zrain=zscore(rainfall)))

ndvi <- ungroup(mutate(group_by(ndvi,SUBLOCATION), 
                       zndvi=zscore(ndvi)))
```

Now we need household mortality data in order to build a model. Get mortality data.

```{r d8}
mort <- data_ibli("marsabit_mortality.rds")

```

Load data with causes of mortality.

```{r d9}
cause <- data_ibli("marsabit_losses")[,c("hhid", "sublocation", "cause","month", "year")]
colnames(cause)[4] <- "season"
s <- cause$season
cause$season <- "SRSD"
cause$season[s >=3 & s <=9] <-"LRLD"
cause <- na.omit(cause)
head(cause, n=2)

```

Merge causes table with mortality data.

```{r d10}
mort2  <- merge(mort, cause, by=c("hhid","sublocation", "season", "year"))

```

Make some plots of cause of deaths.

```{r d11}
temp <- mort2[mort2$type=="TLU", ]
c <- tapply(temp$loss, temp$cause, mean, na.rm=TRUE)
c <- aggregate(loss~cause+year, temp, mean, na.rm=T)
c <- reshape(c, direction="wide", idvar="cause", timevar="year")
colnames(c) <- gsub("loss.", "", colnames(c))
c$cause <- gsub("/.*","", c$cause)
c$cause <- gsub(" .*","", c$cause)
c$cause[c$cause=="Just"]= "Lost"
c <- as.matrix(c)
rownames(c) <- c[,1]
cola <- c("red", "green", "blue", "grey40", "yellow", "black", "orange", "purple", "brown", "skyblue")
par(mfrow=c(1, 1), mar=c(5, 5, 4, 5))
barplot(c[,-1], legend =  rownames(c), las=2, args.leg=list(x = "topright", bty = "n", inset=c(-0.2, 0),cex=1), col=cola, ylab="Livestock loss per TLU")

```

## Spatial Variation
 
Let us explore if there is any spatial variation of average rainfall since 1980.

Load Marsabit shapefile

```{r sp1}
subloc <- data_ibli("marsabit")
```

Check names consistency before merging.

```{r sp2}
a = sort(unique(subloc$SUB_LOCATION))
b = sort(unique(rain$SUBLOCATION))
a[!a %in% b]

```

Now format sublocation names in shapefile to be consistent with those in rain.

```{r sp3}
subloc$SUB_LOCATION <- gsub("\\s*\\([^\\)]+\\)","",subloc$SUB_LOCATION)
subloc$SUB_LOCATION[subloc$SUB_LOCATION=="MARSABIT TOWNSHIP"] <- "TOWNSHIP"
subloc$SUB_LOCATION[subloc$SUB_LOCATION=="MARSABIT TOWNSHIP"] <- "TOWNSHIP"
subloc$SUB_LOCATION[subloc$SUB_LOCATION=="MT. KULAL" ] <- "MT KULAL" 
subloc$SUB_LOCATION[subloc$SUB_LOCATION=="LONYORIPICHAU" ] <- "LONYORI PICHAU" 
subloc$SUB_LOCATION[subloc$SUB_LOCATION=="EL-HADI" ] <- "EL-HARDI" 
subloc$SUB_LOCATION[subloc$SUB_LOCATION=="KURUNGU" ] <- "KARUNGU"

```

Now merge rainfall & NDVI data with sublocation boundary information and plot LRLD and SRSD spatial variation maps.

```{r sp4}
#rainfall
r <- aggregate(rain[, c("zrain","rainfall"), drop=FALSE], rain[,c("SUBLOCATION", "season"), drop=FALSE],mean, na.rm=T)
#ndvi
n3 <- aggregate(ndvi~SUBLOCATION+season, data=ndvi,mean, na.rm=T)
temp <- merge(n3, r, by=c("SUBLOCATION","season"))
#LRLD
lr <- merge(subloc, temp[temp$season=="LRLD",], by.x="SUB_LOCATION", by.y="SUBLOCATION")
#SRSD
sr <- merge(subloc, temp[temp$season=="SRSD",], by.x="SUB_LOCATION", by.y="SUBLOCATION")

cols <- terrain.colors(length(lr$SUB_LOCATION),rev = T)
#Rainfal spatial variation
x11()
spplot(lr, "rainfall", col.regions=cols, main="LRLD Average rainfal per Sub-location: 1982-2019")
x11()
spplot(sr, "rainfall", col.regions=cols, main="SRSD Average rainfall per Sub-location: 1982-2019")

#NDVI spatial variation
x11()
spplot(lr, "ndvi", col.regions=cols, main="LRLD Average NDVI per Sub-location: 1982-2019")
x11()
spplot(sr, "ndvi", col.regions=cols, main="SRSD Average NDVI per Sub-location: 1982-2019")

```

## Modelling Mortality

### Introduction

To design and evaluate an index based insurance contract, we need to understand the relationship between the index (rainfall and NDVI) and losses incurred. Here we develop such a relationship using the z-scored rainfall and NDVI to predict livestock mortality, using survey data from Marsabit.

To establish the relationship we need to estimate mortality for each location and season. We will use household seasonal location average mortality rate $M_{ls})$. However, since sample households varied among the different surveys we will rely on seasonal $s$ average herd mortality per household for each location, $\overline{M}_{ls}$, to compute $M_{ls}$ using

$$
  M_{ls} = \frac{\sum_{m\in s} \overline{M}_{ls} }{\max_{m\in s} \overline{H}_{ls}},
$$ 

where $\overline{H}_{ls}$ is the seasonal *s* (either LRLD or SRSD seasons) beginning herd size averaged per household for each location.

```{r mortality}
mort <- mort[mort$type == "TLU", ]
amort <- aggregate(mort[,c("stock_beginning", "loss"), drop=FALSE], mort[, c("season","year","sublocation"), drop=FALSE], mean, na.rm=TRUE)
amort$mortality_rate <- amort$loss/amort$stock_beginning


```



We mainly care about the mortality rates. Therefore, compute aggregates by year, season and sublocation.


```{r m1}
# mort <- mort[mort$type == "TLU", ]
# amort <- aggregate(mort[,c("stock_beginning", "loss")], mort[ , c("year", "season", "sublocation")], sum, na.rm=TRUE)
# head(amort, n=2)
# amort$mortality_rate = 1 - ((amort$stock_beginning - amort$loss) / amort$stock_beginning )
# amort$mortality_rate[amort$mortality_rate==0] <- NA
```

Merge mortality with NDVI and rainfall data.

```{r m2}
colnames(ndvi)[1] <- "sublocation"
d <- merge(ndvi, amort, by=c("year", "season", "sublocation"))
colnames(rain)[1] <- "sublocation"
d <- merge(rain, d, by=c("year", "season", "sublocation"))

```


Explore the relation between mortality and NDVI.

```{r m3}
cols <- c("red", "blue")
seas <- c("SRSD", "LRLD")
pcols <- cols[match(d$season, seas)]
x11()
plot(mortality_rate~zrain, data=d, xlab="rainfall (mm)", ylab="mortality", col=pcols, pch=20)
legend("topright", seas, col=cols, pch=20)
#NDVI
x11()
plot(mortality_rate~zndvi, data=d, xlab="NDVI", ylab="mortality", col=pcols, pch=20)
legend("topright", seas, col=cols, pch=20)

```


The relationship is a bit noisy (as to be expected). There is a lot of variability at *zNDVI < -1* and *zrain < -1*. That could be a problem; as predictions of mortality at low zNDVI would be quite uncertain. This is why we will do a simulation later.

### Mortality model

Build a local regression model.

```{r m4, message=FALSE}
dd <- na.omit(d[, c("zndvi", "zrain", "mortality_rate")])
library(msir)
m <- loess.sd(dd$zndvi, dd$mortality_rate)
x11()
plot(dd$zndvi, dd$mortality_rate, cex=0.5, col="blue", xlab="zNDVI", ylab="Mortality rate", main="NDVI Mortality Model", cex.lab=1.2, cex.axis=1.15)
lines(m$x, m$y, col="red")
lines(m$x, m$upper, lty=2)
lines(m$x, m$lower, lty=2)

#rainfall
m <- loess.sd(dd$zrain, dd$mortality_rate)
x11()
plot(dd$zrain, dd$mortality_rate, cex=0.5, col="blue", xlab="z-rainfall", ylab="Mortality rate", main="Rainfall Mortality Model", cex.lab=1.2, cex.axis=1.2)
lines(m$x, m$y, col="red")
lines(m$x, m$upper, lty=2)
lines(m$x, m$lower, lty=2)

```

Compare predicted with observed mortality rates.

```{r m5}
#Rainfall
m_r <- loess(mortality_rate ~ zrain , data=dd)
p <- predict(m_r, dd)
plot(dd$mortality_rate, p, xlab="Observed mortality", ylab="Predicted mortality", main="Rainfall model", pch=16, cex.axis=1.2, cex.lab=1.2, cex=0.7)
abline(0,1, lwd=2, col="red")
cat("Rainfall model Residual Standard Error: ", m_r$s, "\n")
#NDVI
m_n <- loess(mortality_rate ~ zndvi , data=dd)
p <- predict(m_n, dd)
plot(dd$mortality_rate, p, xlab="Observed mortality", ylab="Predicted mortality", main="NDVI model", pch=16, cex.axis=1.2, cex.lab=1.2, cex=0.7)
abline(0,1, lwd=2, col="red")
cat("NDVI model Residual Standard Error: ", m_n$s, "\n")

```

We can observe that NDVI & Rainfall model has the least residual Standard Error while NDVI model has the highest standard error indicating low prediction accuracy. We will compare how rainfall and NDVI model to predicts mortality in other years based on their Z-scored *NDVI* and rainfall.

```{r m6}
df <- merge(ndvi, rain, by = c("sublocation", "year", "season"))
#df$year_season <- apply(ndvi[, c("year", "season")], 1, function(x) paste(x, collapse="_"))

head(df, n=2)
#Rainfall predicts
df$rain_mortality <- predict(m_r, df) 
y <- aggregate(rain_mortality~year, df, mean, na.rm=T)
y$r_pay <- y$r_pay[order(y$year)]
y$year <- y$year[order(y$year)]
x11()
plot(rain_mortality* 100~year, data=y, type="l", ylab="Mortality rate (%)", main="Average annual mortality rate using rain data",  axes=FALSE, cex.lab=1.2)
axis(side=1, at=seq(1982,2019, 2), cex.axis=1.1)
axis(side=2, at=seq(0, 20, 5), cex.axis=1.1)
box()

#NDVI predictions
df$ndvi_mortality <- predict(m_n, df) 
y <- aggregate(ndvi_mortality~year, df, mean, na.rm=T)
x11()
plot(ndvi_mortality * 100 ~year, data=y, type="l", ylab="Mortality rate (%)", main="Average annual mortality rate using NDVI data",  axes=FALSE, cex.lab=1.2)
axis(side=1, at=seq(1982,2019, 2), cex.axis=1.1)
axis(side=2, at=seq(0, 20, 5), cex.axis=1.1)
box()

```

### Design

Now that we have a relationship between NDVI and mortality, we can design an insurance contract. Remove some of the higher mortality predictions that occur with high NDVI and rainfall. They are not relevant for us.

```{r m7}
#df$rain_mortality[df$zrain > 0.1] <- 0.1
#df$ndvi_mortality[df$zrain > 0.1] <- 0.1
```

Assume we design an insurance contract that pays when mortality rate falls below the *80th percentile* of the long term series.

```{r m8}
df <- na.omit(df)
r_trig <- quantile(df$rain_mortality, 0.80, na.rm=T)
round(r_trig, 2)
n_trig <- quantile(df$ndvi_mortality, 0.80, na.rm=T)
round(n_trig, 2)

```

The trigger first occurs at the following *zNDVI* and *z-rainfall*.

```{r m9}
tndvi <- max(df$zndvi[df$ndvi_mortality > n_trig])
round(tndvi, 2)
train <- max(df$zrain[df$rain_mortality > r_trig])
round(train, 2)

```

Now let analyse plots of our designed contract.

```{r m9b}
temp <- merge(d[,-c(4:7)], df, by = c("sublocation", "year", "season"))
x11()
plot(ndvi_mortality~zndvi, data=df, xlab="zNDVI", ylab="Predicted mortality", pch=16, cex=0.7)
abline(h=n_trig,col="green")
abline(v=tndvi,col="red")
text(1,0.3, "False Positive")
text(-2,0.05, "False Negatives")
x11()
plot(rain_mortality~zrain,data=df, xlab="z-rainfall", ylab="Predicted mortality", pch=16, cex=0.7)
abline(h=r_trig,col="green")
abline(v=train,col="red")
```


The payout — in units of the monetary value of TLU — are computed following the proposed approach by [Vrieling et al. (2016)](https://www.sciencedirect.com/science/article/abs/pii/S0034425715302248). It uses z-Scored  of an index, e.g *NDVI*, from a season *s* in an insurance location *l* (*zNDVI*$_{ls}$), to estimate indemnity payouts (**as percentage of the insured amount**) *P*  as

$$
    P = \begin{cases} 100,    & \text{if } zNDVI_{ls} < exit  \\
    100 \times \frac{trigger - zNDVI_{ls} }{ trigger - exit }, & \text{if } trigger > zNDVI_{ls} > exit\\
    0,   & \text{if } zNDVI_{ls} >  trigger
    \end{cases}
$$

where the *trigger* is the z-score **threshold** below which the insurance pays, and *exit* is the z-score level corresponding to maximum payment (e.g. 100\% or basically the lowest *zNDVI*$_{ls}$ ). We adopt the trigger at the *80th percentile* of long-term predicted mortality. On the other hand, the exit is approximated as the 5th percentile of the index. 

```{r epay}
epay <- function(index, trigger, exit, frac=1) {
  index <- pmax(index, exit)
  frac * pmax( 0, (trigger-index) / (trigger-exit) )
}
```

Now we use the function to compute payouts based on NDVI and rainfall indices.

```{r m10}
#NDVI based 
#exit   <- min(df$zndvi)
exit <- quantile(df$zndvi, 0.05)
df$n_pay <- epay(df$zndvi, tndvi, exit, 1) * 1000
#Rainfall based 
#exit   <- min(df$zrain)
exit <- quantile(df$zrain, 0.05)
df$r_pay <- epay(df$zrain, train, exit, 1) * 1000

```

Plots for payouts

```{r m11}
#Rainfall
y <- aggregate(r_pay~year+season, df, mean, na.rm=T)
y$r_pay <- y$r_pay[order(y$year)]
y$year <- y$year[order(y$year)]
x11()
plot(r_pay~year, data=y, type="l", ylab="Payouts (USD)", main="Average annual payouts using rain data",  axes=FALSE, cex.lab=1.2)
axis(side=1, at=seq(1982,2019, 2), cex.axis=1.1)
axis(side=2, at=seq(0, round(max(y$r_pay,-1)), by=round(max(y$r_pay)/10,-1) ), cex.axis=1.1)
box()

x11()
boxplot(r_pay~year, data=df,cex=.25,main="Average annual payouts using rain data", xlab="Payouts")

#NDVI
y <- aggregate(n_pay~year+season, df, mean, na.rm=T)
y$n_pay <- y$n_pay[order(y$year)]
y$year <- y$year[order(y$year)]
x11()
plot(n_pay~year, data=y, type="l", ylab="Payouts (USD)", main="Average annual payouts using NDVI data",  axes=FALSE, cex.lab=1.2)
axis(side=1, at=seq(1982,2019, 2), cex.axis=1.1)
axis(side=2, at=seq(0, round(max(y$n_pay,-1)), by=round(max(y$n_pay)/10,-1) ), cex.axis=1.1)
box()

x11()
boxplot(n_pay~year, data=df,cex=.25,main="Average annual payouts based using NDVI data", xlab="Payouts")

```

Let's explore how the payout function behaves.

```{r m12}
#Plot NDVI payout function
x11()
plot(n_pay[order(n_pay)]~zndvi[order(n_pay)], data=df, ylab="Payouts (USD)", xlab="zNDVI", cex.lab=1.2, cex.axis=1.2, pch=16, cex=0.7, type="l")
abline(v=tndvi, col="red")
#Plot rainfall payout function
x11()
plot(r_pay[order(r_pay)]~zrain[order(r_pay)], data=df, ylab="Payouts (USD)", xlab="z-rainfall", cex.lab=1.2, cex.axis=1.2, pch=16, cex=0.7, type="l")
abline(v=train, col="red")
```


```{r}
#dd
```


``

